comando apara instalar usando o composer 

composer create-project laravel/laravel hdcevents 

Rotas 

  Na pasta routes tem o arquivo web.php esse arquivo possui as funções de rotas 
  de uma forma basica a classe Route tem um metodo get que recebe 2 parametros 
  o primeiro e a url eo segundo é um função que vai retornar a view de volta 
  para o cliente. 

  Esse metodo procura as views a serem retornadas dentro do caminho resources/views
  então toda e qualquer rota que vá ser criada no porhjeto tem que estar lá, as rotas
  são o começo eo final da aplicação, porque o cliente reuisita e a rota retorna,
  então compreender esse fluxo é muito importante.
  
   Route::get('/', function () {
    return view('welcome');
    });

 Blade

    O blade é uma template engine reponsavel por rederizar as views isso evita anecessidade de escrever
    php puro para renderizar elementos html. Ele epermite a redenrização condicional de elemntos por exemplo.
    no caso 10 e emenor que 20 então com a condição e falsa ele não vai mostrar o paragrafo.

    @if(10>20)
     <p>A condição e verdadeira</p>
    @endif 

    Enviando dados para a view.
    a função view recebe 2 parametros 1 eo nome da view que ela vai renderizar e o segundo é um array
    contando os dados que eu desejo enviar pra ela, o blade não vê as variveis e sim as chaves desse array
    então se eu queiser mandar seja lá oque for para essa view eu preciso criar uma variavel atriburi a ela
    o valor que eu quero criar uma chave e colocar ela dentro do array como exemplo dessa variavel $nome    

    Route::get('/', function () {

    $nome = "ivan";

    return view('welcome',['nome' = $nome ]);
    
    }); 


    mostrando o valor na view 

     <p>  O valor da variavel nome e : {{ $nome }} </p>

    para mandar mais de um valor e so adicionar mais um indice ao array

    Executando um loop usando blade 

    nesse caso primeiro tem que adcionar um array dentro da função get la na rota 

               Route::get('/', function () {

               $nome = "ivan";

               $arr = [1,2,3,4,5,6];

               return view('welcome',[
                  'nome' => $nome,
                  'arr'  => $arr
               ]);

            });
   para fazer o blade ler e mostrar cada valor contido nos indices, no cadigo abaixo ele usa um for
   para percorrer os indices e mostrar oa conteudo deles e do lado mostrar qual eo numero do indice 
   durante o loop eu adicionai um if que verifica em que momento o valor atinge 2 e quando ele atingir
   vai mostrar uma mensagem avisando que i é = 2 esse codigo é feito em blade na interface.

    @for($i = 0 ; $i < count($arr); $i++ )

      <p>{{ $arr[$i] }} - {{ $i }}</p>

      @if ($i == 2)
       
       <p> i  é igual a 2 </p>
          
      @endif
         
     @endfor


     executando php puro na interface

      @php
         
         // o codigo php fica aqui
       
      @endphp


      Comnatarios usando o blade não saão renderizados nas ferrmantas de desenmvolvedor dos navegadores 
      para usar o blade para copmentar o codigo 

      {{ -- Comentario aqui   -- }}


      usando um foreach no blade  abaixo eu uso a variavel index que ´pe uma palavra reservada 
      digamos se cada inidice desse array tiver um objeto eu posso usar ela pra pegar so o dado
      que eu preciso  mostrar 

      @foreach($nomes as nome)
         
         <p> {{ $loop -> index }}</p>
         <p>{{$nome}}</p>

       
      @endforeach


Adicionando arquivos estaticos 

   Os arquivos estaticos do porjeto como css ,js, imagens devem ficar dentro da pasta public

Layouts usando blade 

   Criar um layout permite o reaproveitamento de codigo,da pra usar o mesmo header e footer em varias paginas 
   todos os layouts dentro doi laravel por padra tem que ter essa nomenclatura 
   NomeDoLayout . blade . php  para que o blade saiba que deve carregar ele na pagina  

   para separar os layouts do projetos criei a pasta layouts na pasta view

   dentro dele eu coloquei o layout principal que vai servir de base para as outras paginas

   esse layout já tem um footer padrão 

   O blade permite que eu faça um adivisão desse Layout atraves de cessoes usando a diretiva 
   @yield('nome_da_cessão') no layout main eu crei duas cessoes 
  
   @yield('title')   -> coloquei no title porque ela vai repsentar o titulo que muda de forma dinamica 
   @yield('content') -> coloquei no body porque ela vai ter o conteudo   

   Para fazer essas varivei funcionarem, no layout que vai receber essas configurações 

   1 - coloque essa diretiva no topo da pagina para apontar para o layout main que foi criado @extends('layouts.main)

   2 - coloque a adiretiva @section('title','titulo_atual_da_pagina') que vai representar o titulo

   3 - coloque @section('content) para iniciar a cessão de conteudo, a variavel content foi definida la no main

   4 - cloque @endsection apara finalizar a cessão de conteudo  

   depois apague as tags body, header, footer(esses elementos ja estão representados pelas variaveis)
   e deixe so conteudo da pagina, devido as configurações o footer vai ser renderizado de forma automatica
   e o header tambem 

   --------------------------------------------------------------------------

   vou instalar no layout principal o google fonts e o bootstrap assim ele ja extende pára todas paginas tambem

   -----------------------------------------------------------------------------------------------------------------

   PASSANDO PARAMETROS ATRAVES DAS ROTAS 

    Enviar aparametros atraves das rotas é algo util para moldar o comportamento que a pagina vei ter baseado no dado
    de requisição que ela esta fazendo. No caso abaixo a rota product vai receber um id de um produto e eu vou pegar o valor dele
    e jogar dentro do array. 

    Route::get('/product/{id}', function ($id) {


     return view('product',['id' => $id] );
    });

    No caso eu coloquei um fluxo de decisão dentro da pagina baseada no id recebido 
    se o id for 0 o cliente chegou nessa pagina por acidente sem selecionar nenum item
    então a pagina exibe uma mensgame pedindo que ele volte e selecione algum produto
    se a url vier com id 1 ela mostra o porduto 1.

    @if ($id == 0)

       <p>Por favor selecione um produto </p>
     
       <p>O id recebido e: {{ $id }}</p>

       @elseif ($id == 1)

            <ul>
                <li>Camiseta polo branca</li>
                <li>Preço: 69,99</li>
            </ul>
       @elseif ($id == 2)

            <ul>
                <li>Camiseta polo Azul</li>
                <li>Preço: 69,99</li>
            </ul>
                
                    
         @endif


         --------------------------------------------------------------------------------------


 CONTROLLERS
  
       Os controllers são responsaveis pela parte logica de toda a aplicação. o alaravel possui uma classe controller 
       e todo o controller criado tem que herdar ela para que funcione de forma correta.Por padrão o nome de um copntroller 
       e no singular se estou crindo um sistema de eventos então o controller e EventController. 

       comando para egrar um controller 

        php artisan make:controller EventController 
       
       controller gerado pelo comando 

       <?php

            namespace App\Http\Controllers;

            use Illuminate\Http\Request;

            class EventController extends Controller
            {
               //
            }

      ----------------------------------------------------------

      dentro dele eu crio a função publica index()  um ponto importante a ser abordado e que  
      NUNCA a logica deve ser posta dentro das rotas elas sempre são colocadas dentro do controller 
      eu iniciei colocando dentros das rotas para fins de testes.

      nesse caso toda a parte de envio de paremetros, tratamento de parametros recebidos, todos devem ser postos dentro 
      de uma função no controller e ele fica assim 


      <?php

            namespace App\Http\Controllers;

            use Illuminate\Http\Request;

            class EventController extends Controller
            {
               public function index(){

                  $nome = "ivan";

                  $arr = [1,2,3,4,5,6];
               
                  return view('welcome',[
                        'nome' => $nome,
                        'arr'  => $arr
                  ]);


               }
            } 

     --------------------------------------------------------------------------------------------------

     como a rota vai saber que tem que acessar a função index() la dentro do controller 

     1 - importar ele pra dentro do arquivo web.php

      use App\Http\Controllers\EventController;
   
     2 - passar ele como segundo parametro da rota como se fosse um array,
         no codigo abaixo eu digo que a classe EventController tem a função index 
         e tudo oque vier da rota / vai ser mandado pra lá

      Route::get('/',[ EventController::class, 'index']);

      e sempre que uma view precisar ser criada no sistema a sequencia e a seguinte

      1 - crie a view adicione as variveis do layout main
      2 - crie dentro do controller uma função para tratar os dados vindos dessa view    
      3 - crie a rota passando o controller e depois a função como paramentro via array
      
    ------------------------------------------------------------

    Rota create segue o mesmo padrão

    --------------------------------------------------------------
CONECTANDO A ABSES DE DADOS 
   
   O laravel possui um arquivo chamado .env  esse arquivo guarda as configurações do banco 
   oque deve ser alterado nele são somente tipo do banco , porta se necessario usuario e 
   senha e o nome da base de dados.na configuração abaixo eu estou pontando por meu banco 
   local, porquestões de segurança quando o porjeto é versionado esse arquivo não mantem
   as configurações. 

      DB_CONNECTION=mysql
      DB_HOST=127.0.0.1
      DB_PORT=3306
      DB_DATABASE=hdceventscurso
      DB_USERNAME=root
      DB_PASSWORD=  
   
   O laravel tem um comando inicial para criar tabelas para armazenar usuarios , trocar passwords
   essa tabelas são criadas usando o comando 

   php artisan migrate 

   MIGRATIONS 
     São classes que são geradas usando a estrategia ORM que mapeia as tabelas como se a entidade fosse uma classe 
     e os atributos fossem as colunas. o alaravel ja vem com as algumas migrations criadas mas essas migrations são
     pre-definidas para criar na abase de dados as tabelas reponsaveis pelo cadastro de usuarios da aplicação.

     criando uma tabela no banco usando uma migration primeiro informamos oque é pra fazer 'create' depois o nome da tabela 'produtos' 
     e depois oque ela é 'table' esse comado vai criar uma classe onde produtos vai ser a classe e podemos adicionar os atributos nela 

     


     php artisan make: migration create_produtos_table 

     comado pra ver se as migration foram rodadas ou não 

     php artisan migrate:status 

     comando apa executar as migrations pendentes de forma geral  

     php artisan migrate 

     quando é necessario atualizar uma tabela com novos campos o comando usado é:

     php artisan migrate:fresh

     porem tem que ter cuidado porque ele deleta todas as tabelas e depois refaz para atualizar se tiverem dados eles seram pedidos.

     mas existem comendo onde se pode alterar a estrutura de uma tabela sem perder dados 

     para adicionar um campo a um tabela de forma incrementalç sem perder dados usamos o comando,
     o cmando abaixo e bem claro em ralaçãop ao oque tem que fazer. "adicione categoria a tabela produtos"

     php artisan make:migration add_category_to_products_table 

     criando uma tabela 

     php artisan make:migration create_products_table 

     depois de adicionar os campo e fazer as modificações necessarias para rodas a migration 

      php artisan migrate

     para atualizar a estrutura da tabela adicionando um campo sem perder dados 

       php artisan make:migration add_category_to_products_table 

      depois de ir na migration adiccionar esse campo nos dois metodos

       php artisan migrate

       "todos os campos que forma adicionados dentro de uma migration tem que se adicionados nos dois metodos
        para que a migration tanto posssa adicionar quanto destruir os campos quando necessario o metodo up 
        serve para criar e o metodo down para destruir as colunas então as colunas devem serd declaradas nos dois "


        no metodo up fica dessa forma

           public function up()
    {
        Schema::create('products', function (Blueprint $table) {
            $table->id();
            $table->string('name',100);
            $table->integer('qty');
            $table->string('description',100);
            $table->timestamps();
        });
    }






        no metodo down fica dessa forma 

        public function down()
    {
        Schema::dropIfExists('products');

        $table->dropColumn('name',100);
        $table->dropColumn('qty');
        $table->dropColumn('description',100);


    }
   

   Depois que uma migration e geradas e executada a tabela e gerada na base de dados a porxima e tapa consiste em resgatar 
   os dados presentes dentro dessa base de dados. isso aocntece traves dos models criando um model ele tem o nome no singular
   porque todos os objetos gerados apartir da classe Event serão os events no plural como se o model se comportasse como uma 
   coleção.

   php artisan make:model Event

   Resgatando os dados do banco 

   1 - vai no EventController app/http/Controllers/EventController.php chama o model para dentro do arquivo usando a diretiva 

      use App/Models/Event;

   2 - quando você chama a classe model para dentro do controller da pra usar os metodos dela pra trazer tudo usamos o metodo all();
       e atribuimos o valor contido nele a uma variavel qua seria a $events, como são varios eventos temos que distribuir em um array 
       que seria o segundo parametro do metodo view(); 
        
      

      $events = Event::all();

       return view('welcome' , ['events' => $events ]);

   3 - la na view usando a sintaxe do blade faz um foreach  assim voce tera todos os eventos da base de dados listados na interface
       no caso abaixo eu to pegando as propriedades titulo e descrição  
        
      @foreach($events as $event)

        <p>{{$event->title}} -- {{$event->description}}</p>       
        
      @endforeach


      ADICIONANDO REGISTROS NO BANCO DE DADOS 

        A primeira parte consiste em fazer o formulario nos atributos de action coloca-se a rota de criar eventos "/create"
        e no atributo method se coloca um POST, dentro da tag form todos os elementos e divs devem perrtencer a classe form-control
        para que os framework bootstrap organize eles.

        No aruivo web.php tem que criar uma rota apontando para o metodo store que vai chamar esse metodo la dentro do controlller

        Route::post('/events',[ EventController::class, 'store']);

        depois de fazer isso tem que criar a função store la dentro do controller essa função recebe um parametro chamado $request 
        o paramtro request pelo oque eu entendi trata-se de um objeto dinamico que traz os atributos do objeto dentro dele, assim
        eu crio um objeto da classe Event e seleciono o tributo title e dentro dele eu jogo o valor do title vindo da request 
        como se fosse um espelho. 

        A função save é usada pra salavar no banco de dados como o meu objeto esta baseado no model que ja tem essa função 
        e só usar.

        deposi de salvar os dados eu redireciono o cliente para página home   
      
      
      public function store(Request $request){
       
      /* instanciando um objeto da com base na classe do model pra poder puxar os atributos*/
        $event = new Event;

        $event->title = $request->title;
        $event->city  = $request->city;
        $event->private = $request->private;
        $event->description = $request->description;

        $event->save();

        return redirect("/");
        
     }

     NO FORMULARIO 
       o blade possui um sistema de proteção chamado csrf absolutamente todo formulario que for se comeunicar com
       a base de dados precisa ter a diretiva @csrf dentro da tag form se não ele não envia os dados.

      com essas configurações ele insere os dados na base de dados sem o uso da sintaxe sql 

    FLASH MESSAGES 
       As flash messages servem para avisar ao cliente que uma ação foi concluida mensagens do tipo "salvo com sucesso" são uteis 
       para que o cliente saiba que de fato a aplicação atendeu a sua solicitação.

    criando flash messages no laravel.

       primeiro essa mensagem, deve ser adicionada no controller dentro da função que vai disparar ela, no caso eu desejo que  
       após o cliente inserir um novo eneto no sistema ele seja redirecionado para a home e receba o aviso de que o evento foi 
       incluso com sucesso, o processo de salvar um noco evento no sistema esta sob a responsabilidade da função store então 
       a diretiva deve ser inclusa dentro dela dessa forma.

       return redirect("/")->with('msg', 'Evento criado com sucesso !');

       No codigo acima alem de retornar o redirecionamento ele usa o metodo with para incluir mais alguma coisa no retorno 
       e essa alguma coisa tem que ter o identificador eo conteudo, identificador msg conteudo a mensagem de fato. 

       O segundo passo tem que ir na view create e criar essa estrutura, dentro das tags html exite um teste de cessão  que vai verificar se  
       existe alguma mensagem na cessão que deva ser entregue, se sim ele mostra a mensdagem e segue para exibir o resto do layout senão ele so exibe o layout mesmo

                     <main>
                  
                        <div class="container-fluid">
                           
                           <div class="row">

                           @if(session('msg'))

                           <p class="msg">{{ session('msg') }} </p>
                           
                           @endif
                           @yield('content')

                           
                           
                           </div>
                        
                        </div>
                  
                  
                  </main>  
         isso é sufiente para a mensagem, aparecer  

         --------------------------------------------------------------------------------------------------------------

         SALVANDO IIMAGENS NO BANCO DE DADOS COM O LARAVEL 

         A primeira etapa consiste em criar configurações de entrada no formaluario a primeira alteração e colocar o atributo enctype
         que informa ao sistema que esse formalario alem de mandar texto tambem vai mandar arquivos.esse atributo  e colocado no form.

                  <form action="/events" method="POST" enctype="multpart/form-data">

         campo responsavel por receber a imagem :

                  <div class="form-group">
                  
                  <label for="image">Imagem do evento:</label>
                  <input type="file" id="image" name="image" class="forma-control-file">
            
               
                  </div>
         é sepre importante lembrar no banco de dados ficam salvo o nome da imagem ou a url de localização, o arquivo de fato fica dentro,
         de uma pásta nas dependencias do porjeto.com essas duas aletarções a view ja estara pronta, a porxima etapa e fazer a logica no controller dentro do contoller  
         na função store a logica fica assim:


                           /*Image upload testandop se a imagem é um arquivo valido */
                     
                     if($request->('image') && $request->file('image')->isValid()){

                        // puxando o tributo image da request
                        $requestImage = $request->image;

                        //puxando o atributo extensão da imagem 
                        $extension = $requestImage->extension(); 
                        
                        // pegando o nome do arquivo de imagem e a hora do servidor no momento do upload e gerando um 
                        //rash md5 e concatenendo o rash com a extensão da imagem.O motivo de usar rash e pra tornar o 
                        ///nome da imagem unico dentro do servidor 

                        $imageName = md5($requestImage->getClientOriginalName().strtotime('now').".".$extension);

                        //direcionando o arquivo de imagem para a pasta correta para isso eu uso uma função chamada move 
                        //que recebe 2 parametros o path que a pasta onde vai ser salvo eo nome do arquivo que vai ser salvo  

                        $requestImage->move(public_path('img/events'), $imageName);

                        
                     }


         O proximo passo e criar uma migration que adicione o campo da imagem na tabela

         O proximo passo agora e fazer com oque essa imagem escolhida pelo cliente seja presentada junto com o evento ao qual ela faz referencia 
         então a imagem do card que repesenta um evento ao invez de ficar com uma imagem estatica vai mostrar a imhgem gerada no evento correspondente

           <img src="/img/{{$event->image}}" alt="{{$event->title}}">
         --------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      usando eloquent para visualizart os detalhes de um evento especifico

      O primeiro passo começa criando uma nova rota de get la no web.php essa rota chama função show dentro do controller 

      Route::get('/events/{$id}',[ EventController::class, 'show']);

      No caso apra enviar esse id que vai acionar a rota tem que ir la no card colocar no link saiba mais esse link 
      vai pegar o id do evento e mandar para a rota a rota vai colocar o id na funçãio show. a função show vai usar o id 
      como um parametro para o metodo findOrFail() que pérnetynce a classe Event que serve para fazer uma busca pelo evento
      dentro da base de dados e jogos os dados dele dentro da variavel $event que vai ser retornada junto com a view show
      e la vamos pegar os dados do evento e p´reencher os elementos.   


                  public function show($id){
                  
                  $event = Event::findOrFail($id);

                  return view('events.show',['event' => $event]);

               }


     -----------------------------------------------------------------------------------------------
     usando json no laravel pra pegar itans de multipla escolha 

     O primeiro passo e fazer uma migration adicionando a coluna itens na tabela events ao inves do tipo de dado 
     ser string vai ser json dessa forma.

      $table->json('items');

    O segundo passo e ir no front e criar os check boxes que vão ser selecionados 
    o terceiro e criar logica que vai receber os dados la no controller
    pegando os itens através da request. 

     $event->items = $request->items;

     Mas nesse caso somente isso não basta para o laravel salvar um array na base de dados, e necessario avisara la no model 
     que vai vir um array de itens senão ele vai tentar salvar como array, posucas mudanças são feitas dentro do model. o model 
     nesse caso vai ficar assim: 

         protected $casts = [

            'items' => 'array'
         ];
     $casts é uma varivel interna do laravel que armazena configurações de conversão no caso acima eu estou dizendo que todos os dados 
     que tiverem dentro de itens devem ser salvos e interpretados como array.isso ja vai ser suficinerte para salvar na base de dados como array 

     IMPRIMINDO UM ARRAY NA VIEW 
     
     um foreach normal do blade funciona 

     ----------------------------------------------------------------------------

     SALVANDO DATAS DENTRO DO LARAVEL

     O tratamento de datas se inicia criandop uma migration para adicionar essa coluna na tabela de eventos 
     depois temos que informar ao model sobre o campo date:

      protected $dates = ['date'];

      depois temos que crirar o campo la na view 

      depois tem que ir la no controller dentro da função store e pegar o valor pela request, quando essa data
      é salva no banco ela fica no formato norte americano mas apara oc liente ela tem que aparecer no formato normal,
      para fazer essa correção 

      1 - aciono a função date que recebe 2 parametros  
          date('como eu quero que a data seja exibida ' , 'os dados que eu vou receber' );

      2 - o primeiro parametro eu escrevo como eu quero que a adata seja mostrada , no segundo eu uso outra função 
          strtotime() que serve para converter a string que eu estou recebendo em um dados de tempo nisso ela é reconehcida pela função date 
          que compreende os numeros e faz a ordenação em dia mesm e ano como euy pedid no primeiro parametro.

      {{ date('d/m/y',strtotime($event->date)) }}  

      ----------------------------------------------------------------------------------------------------------------

      BUSCA DE DADOS NO LARAVEL 
        
        No caso desse projeto o sistema de busca não vai ter um botão buscar, o cliente vai digitar oque quer e apoertar enter 
        então comecei ajustando as configurações do input de busca na view 

                  <div id="search-container" class="col-md-12">

                  <h1>Busque um evento</h1>

                  <form action="/" method="GET">
                     
                     <input type="text" id="search" name="search" class="form-control" placeholder="procurar...">
                  
                  </form>   
               </div>

      A logica para a busca dentro do controller funciona assim: 

      primeiro eu criei uma varivel dentro da função index, chamada search essa varivel vai receber 
      o valor que vem da função request(); que como o nome ja diz ela vai requisitar o valor que vem
      do input que tem o nome serach la na view nisso a variavel search ja pega oque foi digitado.

      depois eu faço um teste pra saber se tem alguma coisa dentro da varivel $search usando um if-else
      se sim eu crio a variavel $events e depois eu chamo a classe do model Events::where(); e uso o metodo
      where.

      O mtodo where recebe um array que monta a consulta  nesse caso ele vai pesquisar pelo titulo qualquer letra que seja como a letra inicial ou final 
      contida dentro da variavel $search mas para pegar o resultado retornado nessa busca eu poreciso usar o metodo get(); que vai de fato preencher a variavel $events como o r
      resultado da busca 

          $events = Events::where(
            [
             ['title','like','%'.$search.'%']
          
            ] 
            )->get();

       alem disso eu vou mandar ela pra view tambem 

         return view('welcome' , ['events' => $events, 'search' => $search ]);


      com isso a busca ja funciona normnalmente
      
      -------------------------------------------------------------------------------------------------------------
      AUTENTICAÇÃO NO LARAVEL USANDO JETSTREAM 
        Antes usar esse recuros de fato existe uma sequencia de comandos que devem ser executados e importante que seja nessa ordem 

        1 - composer require laravel/jetstream 
        2 - php artisan jetsream: install livewire 
        3 - php artisan migrate 
        4 - npm install 
        5 - npm run dev

      esses comandos em sequencia instalam uma serie de recursos para construir o sistema de login 
      //resovi o bucho da interface de login eliminando a diretiva @vite e colocando essas duas linhas no app.blade.php 

        <link rel="stylesheet" href="{{ asset('css/app.css') }}">
        <script src="{{ asset('js/app.js') }}" defer></script>
        link solução do problema

        https://stackoverflow.com/questions/73180945/jetstream-css-and-js-not-working-and-showing-viteresources-css-app-css-re

        -----------------------------------------------------------------------------------------------------

        USANDO A AUTENTICAÇÃO PARA AUTENTICAR 

         Com os passos que foram feitos acima eu ja tenho como criar um usuario e logar usando ele mas isso precisa ser implemntado 
         no sistema a primeira etapa é modificar a interface, se o cliente estiver autenticado dois elementos não precisam aparecer
         para isso eu coloco os dois dentro da diretiva @guest, essa diretiva faz um fluxo de decisão que verifica se o usuario esta 
         logado  ou não está noi caso abaixo se o susuario estiver logado nmão vao aparecer os links de entrar e nem o de cadastrar 
         por motivos obvios.  


         
                 @guest
                                 

                 <li class="naviten">
                   <a href="/login" class="nav-link">Entrar</a>
                 </li>

                 <li class="naviten">
                    <a href="/register" class="nav-link">Cadastrar</a>
                 </li>

                 @endguest  



          A questão do logout para deslogar o cliente usa-se a diretiva @auth onde ele lé autenticação e usa ela  
          e quando ningem acionar o link que leva para o logout o cliente fica conectado, a diferença do logou e que 
          para sair isso tem que ser avisado ao framework que é em php então nesse caso eu uso um formalario para mandar
          a informeção via POST como pode ser visto no link sair, esse link opnta pra função logout e para que ele não va para outro lugar 
          eu executro uma função js prevent defalt para ele acionar a função do framwor sem sair da pagina ou abrir outra pagina
          porque nesse caso eu so quero quie ele libere o cliente.


            @auth
                 <li class="naviten">
                   <a href="/dashboard" class="nav-link">Meus eventos</a>
                 </li>

                 <li class="naviten">
                   <form action="/logout" method="POST">
                      @csrf
                      <a 
                         href="/logout"
                         class="nav-link"
                         onclick="event.preventDefault(); this.closest('form').submit();"        
                        >Sair</a>
                   </form>
                 </li> 

            @endauth

            EXPLICANDO A FUNÇÃO DO ONCLICK 
              
               O atributo onlick nesse caso vai acionar duas funções uma e a event prevent default para o link não fazer oque 
               ele faz normalemente, assim ao ser acionado o link vai fazer oque eu disser no caso eu chamo uma segunda função 
               que pega o formaulario mais proximo que  e esse que o link esta dentro e executa um submit acionando o envio dele 
               via post ou seja ao inves do link nos levar a outra pagina ele da um submit no formulario.  


             onclick="event.preventDefault(); this.closest('form').submit();"
             
             final da aula 22 
             -----------------------------------------------------------------------------------------------------------------------------

             REALACIONAMENTO ENTRE TABELAS NO LARAVEL 

              O objetivo do relacionamento entre tabelas nesse caso como setrasta de um sistema de eventos e possibilitar que um usuario 
              de fato seja dono de um ou mais eventos dentrod o sistema é um tipoo de relação de 1 para muitos.

              O primeiro passo consiste em adcionar o id do usuario como um, dos campos da tabela eventos astraves de um comando de migration

              php artisan make:migration add_user_id_to_events_table

              A principal diferença entre essa coluna e uma colunas normal e que ela vai abrigar um chave estrangeira e isso precisa ser informado 
              na migration, tanto tem que ter um jeto de adicionar e descartar esse campo, mas caso ocorra dele precisar ser deletado o usuario 
              associado a ele tem que ir junto pra não ficar um cliente sem id dentro da base. então a migration fica assim:


                         <?php
                              use Illuminate\Database\Migrations\Migration;
                              use Illuminate\Database\Schema\Blueprint;
                              use Illuminate\Support\Facades\Schema;

                              class AddUserIdToEventsTable extends Migration
                              {
                                 /**
                                 * Run the migrations.
                                 *
                                 * @return void
                                 */
                                 public function up()
                                 {
                                    Schema::table('events', function (Blueprint $table) {
                                          $table->foreignId('user_id')->constrained();

                                    });
                                 }

                                 /**
                                 * Reverse the migrations.
                                 *
                                 * @return void
                                 */
                                 public function down()
                                 {
                                    Schema::table('events', function (Blueprint $table) {
                                       
                                          $table->foreignId('user_id')
                                          ->constrained()
                                          ->onDelete('cascade');
                                          
                                    });
                                 }
                              }


                      Migration pronta agora temos que preparar o model, no model tem que criar uma função chamada user 
                      ela não recebe parametros no entanto ela liga o susurio ao model usando a função belongsTo que pertentence
                      ao proprio objeto usuario.   

                      public function user(){

                              return $this->belongsTo('App\Models\User');
                     }

                     agora dentro do model user aqui usando a função publica evets dentro de um model usuario eu aviso 
                     que toda vez que um eventos chamkar essa função ele vai saber que um ususario tem ou pode ter varios 
                     eventos.dessa forma tanto o usuario sabe que pode ter varios eventos quanto o evento sabe que  petence
                     a um usuario

                     public function events(){

                             return $this->hasMany('App/Models/Events');
                       }

                     isso vai ajudar a saber quais os eventos pertancem a qual usuario e qual usuario e dono de qual evento.
                     quando a migration for rodada temn que ser a migration fresh senão ele vai dar um erro porque estamos adicionando um campo 
                     que precisa ter um referencia.


                     o proximo passo e pegar op usuario logado la no controller não adianta ter o campo de id se ele não for preenchido 
                     isso acontece por meio do controller essa duas linhas ficam de ntro da função styore responsavel pela gravação, a primeira 
                     linha chama função auth() que tem o objeto usuarios dentro dela e puxa somente o oibjeto usuario. e coloca dentro da variavel 
                     user, na segunda linha eu chamo o objeto evento e pego del o atributo user_id e coloco no atributo usar id do objeto, preenchendo o campo 
                     dentro da base de dados assim eu sei quem e que esta logado.     

                       $user = auth()->user();
                       $event->user_id = $user_id;

                     para evitar que algum grave um evento sem estar logado tem que ir la na rota e adicionar  a função que vai acontecer no 
                     meio termo entre o cliente clicar e receber a pagina, no caso eu coloquei pra executar no middleware a função auth que vai checar 
                     se o susrio realmente esta logado. essa alteração faz com que toda vez que o cliente clicar em criar eventos ele seja enviado a 
                     uma tela de login no sistema

                     Route::get('/events/create',[ EventController::class, 'create'])->middleware('auth');

                     ---------------------------------------------------------------------------------------------------------------------------------
                     MOSTRANDO OS DADOS DO USUARIO LOGADO NA VIEW

                     O primeiro passo e importar o model user para dentro do controller para que eu possa puxar a função where e todos os atri0butos de um usuario 

                     use App\Models\User;  

                     O segundo passo e colçocar uma variavel que vai receber o resultado da função where que agora pode ser usada dentro da função show, no caso 
                     a função where vai pegar o atributo do user_id do evento para fazer a consulta a função first serve para ele pagar o primeiro que ele encontar 
                     na base de dados com o id recebido pela consulta isso evita dele fazer uma busaca em todo od banco de dados pre ver se tem mais algum usuario 
                     com esse id, e depois eu uso a função toArray() pra ele transformar todos os dados do objeto que ele achar em um array pra eu poder acessar 
                     cada um dos indices. 

                     $eventOwner = User::where('id', $event->user_id)->first()->toArray();

                     isso é suficiente pra pegar os dados, agora o proximo passo e enviar esses dados pra view agora e so ir na view e puxar os atributos

                      return view('events.show',['event' => $event, 'eventOwner' => $eventOwner ]); 

                     como eu pedi pra ele converter pra array então eu pego os dados pelo indice 

                       <p class="event-onwer"><ion-icon name="star-outline" ></ion-icon>{{ $eventOwner['name'] }}</p>

                      --------------------------------------------------------------------------------------------------------------

                      CRIANDO UMA DASHBOARD PARA O USUARIO 
                      
                      Dentro da pasta porfile existe a view dashorda pra onde o sistema manda por default o usuarios logado so que  
                      ao inves de usar uma dash board ja criada pelo jetsream eu vou fazer uma propria aproveiutando o poroprio arquivo
                      primeiro foi criada um rota do tipo get apontando para o controller fazendo referencia a uma função chamada dashboard,
                      nessa função eu peguei os dados do login usando a função auth() depois usandop usar pra pegar o usuarioe atribui esse valor 
                      a variavel $user depois peguei do ubjeto usuario os eventos e coloquei na veriavel $events depois eu chameia a view dashboard 
                      que eu copiei o aruivo da pasta porfile pra dentro da pasta events por isso eu to chamando a dasboard de dentor da pasta events 
                      de depois passei o valor da varivel events junto com a view dashboard pela rota, como eu estou pegando o susrio logado como referencia 
                      todos os ventosd contidos na events ja são pétencentes ao ususario que esta logado.       

                      public function dashboard(){

                           $user = auth()->user();

                           $events = $user->events;

                           return view('events.dashboard',['events' => $events]);

                       } 

                       ------------------------------------------------------------------------------------------------------------
                  DELETANDO EVENTOS

                    A primeira coisa a ser feita e criar a rota embora ativodade dessa função seja deletar o nome padrão para ser usado 
                    no laravel para esse tipo de função é Destroy.

                    Route::delete('/delete/{id}',[EventController::class, 'destroy']); 

                    O proximo passo e criar essa função la no controller recebedo o paramentro id que vem pela rota ela recebe o id
                    a função que vem do model Event executa o metodo de busca findOrFail para achar o id depois que ele acha ele executa 
                    o delete. isso e suficiente para apagar o evento. e pdois eu redirecionao o cliente de volta apara a dashboard junto com a mensagem

                    
                   public function destroy($id){

                        Event::findOrFail($id)->delete();

                        return redirect("/dashboard")->with('msg', 'Evento excluido com sucesso !');

                  }
                  ---------------------------------------------------------------------------------------------------------------------------
                  EDITANDO UM REGISTRO 

                  O primeiro passo é adicionar um as rotas a primeira leva a pagina de edição a segunda aciona a função update  

                  Route::get('/events/{id}',[EventController::class, 'edit'])->middleware('auth');
                  Route::put('/events/update/{id}',[EventController::class, 'update'])->middleware('auth');
                  
                  O segundo passo e colocar a função publica edit la no controller pra rota poder acessar ela, para que essa função saiba que evento ela vai editar 
                  ela recebe o id como parametro. a função edit vai pegar os dados para preencher o formulario de edição com os dados atuais 

                              public function edit($id){

                                 $event = Event::findOrFail($id);

                                 return view('events.edit', ['event' => $event ]);       

                              }

                  a função update faz a requisição baseada no id que vai chegar pra ela pela rota, a avariavel $data vai armazenar tudo que vier na requisição 
                  abaixop eu uso a mesma logica pra validar se esta vindo um aruivo de imagem valido deposi da checagem eu atibuo o indice imagem do array data 
                  ao nome da imagem, depois eu uso o metodo findOrFail() do Event para fazer uma busca pelo id e ataualizar todos os dados contidos na variavel $data
                  deposi eu redirecioono o cliente pra dashboard.  

                           public function update(Request $request){

                                 $data = $request->all();

                                 // Image Upload
                                       if($request->hasFile('image') && $request->file('image')->isValid()) {

                                          $requestImage = $request->image;

                                          $extension = $requestImage->extension();

                                          $imageName = md5($requestImage->getClientOriginalName() . strtotime("now")) . "." . $extension;

                                          $requestImage->move(public_path('img/events'), $imageName);

                                          $data['image'] = $imageName;

                                    }




                                 Event::findOrFail($request->id)->update($data);

                                 return redirect("/dashboard")->with('msg', 'Evento editado com sucesso !');
                                    
                                 
                           }

                           IMPÓRTANTE LEBRAR 
                           1 - NO MODEL EVENT TEM UMA RETRÇÃO DE SEGURANÇA QUE SO DA PRA PASSAR SE COLOCAR ESSA LINHA DE CODIGO 
                               NESSA VARIVEL FICAM SO AS COISAS QUE TEM PREMISSÃO PRA MANDAR OA DADOS COMO O ARRAY TA VAZIO ENTÃO TO LÇIBERANDO TODOS OS 
                               DADOS QUE VIEREM DO UPDATE  

                               protected $guarded =[];

                ------------------------------------------------------------------------------------------------------------------------

                CRIANDO UM RELAÇÃO DE MUITOS PARA MUITOS 

                  O primeiro passo e fazer um migration que cria uma tabela que vai relacionar usuarios e eventos no caso a nomenclatura 
                  deve ser criada na ordem alfabetica.e vem primeiro que u então event_user. essa tabela vai ser ponsavel por ligar o id 
                  do evento ao id do usuario 

                  php artisan make:migration create_event_user_table

                  configurando o relacionamento na migration 

                    $table->foreignId('event_id')->constrained();
                    $table->foreignId('user_id')->constrained();

                  O proximo passo e no model Event tem que criar uma função que aponta para o model usuarios e virse e versa 
                  MODEL EVENT
                  ---------------------------------------------
                    public function user(){

                        return $this->belongsToMany('App\Models\User');
                     }


                  MODEL USER
                  ------------------------------------------
                  public function eventsAsParticipant(){

                        return $this->belongsToMany('App\Models\Event');
                     }

                  Essas funções vão ligar um model ao outro 

                  LIGANDO UM USUARIO A UM EVENTO PELO BOTÃO PARTICIPAR 

                Primeiro tem que criar a rota para que o botão confirmar presença mande os ids por ela 

                Route::post('/events/join/{id}',[EventController::class, 'joinEvent'])->middleware('auth');

                O proximo passo e construir a função pra onde essa rota aponta dentro do controller 
                                     
                 -------------------------------------------------------------------------------------------
                 essa função recebe o id como parametro que vem pela rota, depois ela pega o usuario autenticado que vvem da função auth 
                 depois ela seleciona a função eventAsParticipant() que liga o ususario ao evento de ela usa a função attach() para anexar o id 
                 eo campo da tabela depois ela faz a buca pelo is do evento usando a função findOrFail() do model Event() pra preencher na tebela 
                 e unir os dois, depois ela redireciona o cliente para a dashboard com a mensagem de feedback e o titulo do evento. 

                  public function joinEvent($id){

                        $user = auth()->user();

                        $user->eventAsParticipant()->attach($id);

                        $event = Event::findOrFail($id);

                        return redirect('/dashboard')->with('msg', 'sua presença está confirmada no evento'.$event->title);
                   }

                   la na view show tem que configurar o botão 

                      <form action="/events/join/{$event->id}" method="POST">

                        @csrf
                        
                              <a href="/events/join/{$event->id}" class="btn btn-primary" id="event-submit" 
                                 onclick="event.preventDefault(); this.closest('form').submit();"
                              > Confirmar presença</a>
                        
                        
                        </form>


                     se der erro de dados invalido olha se não esqueceu de colocar chaves duplas 
                     ------------------------------------------------------------------------------------------------------------------

                     MOSTRANDO NA DASHBOARD  

                     ir no controller na função dashboard chamar a veriavel e mandar o valor dela pela rota 

                            $eventsAsParticipant = $events-> eventAsparticipant; 

                            return view('events.dashboard',['events' => $events, 'eventasparticipant'=> $eventsAsParticipant]); 

                     


               










                     

                  



                               
                           

                  
                  













                      
                                                              

















                      
                     






                     


  





         







      
        
      

      

      

      





         


      

      









     











       



         



         


          
         




         




    


     


        














    ----------------------------------------------------------------------------

    

       

      












     

     
     












   


   


      



















 
          
    













   
    


     





